---
id: access-log
title: 'Next.js access log: 다양한 환경과 실행 방식에 따른 최적의 로깅 전략'
description: 'Next.js application에서 access log를 손쉽게 구현할 수 있는 방법에 대해 알아봅니다.'
preview: 'Next.js application에서 access log를 손쉽게 구현할 수 있는 방법에 대해 알아봅니다.'
keywords: 'next.js, next, access-logs, access-log, accesslog, frontend, logging'
slug: nextjs-access-log
createdAt: 2024.12.05
published: true
---

로깅은 애플리케이션의 상태를 추적하고, 성능 문제를 진단하며, 치명적인 오류를 기록하는 데 필수적이다. `Next.js`는 프레임워크 수준에서 로깅을 자동으로 처리하지 않아 불편한 부분이 있지만, 조금만 고민하면 이를 유연하게 구현할 수 있다고 생각한다.

로그를 출력하는 것은 단순히 요청과 응답 정보를 기록하는 것을 넘어, **분산 시스템의 상태 모니터링**, **성능 최적화**, 그리고 **보안** 같은 부분을 고려해야 한다. 특히 **고트래픽 환경**에서는 로그의 양이 성능과 비용에 직접적인 영향을 미치기 때문에, 실행 방식과 설계가 더욱 중요하다.

이번 글에서는 `Next.js`에서 처리할 수 있는 로깅 메커니즘을 기술적으로 심층 분석하고, **출력 방식**, **중앙집중적 로깅 관리**, **동기식/비동기식 실행 방식**에 따라 최적의 로깅 전략에 대해 이야기 해 볼 예정이다.

## 1. 로깅 출력 방식

### 1.1. Next.js의 기본 출력 방식

Next.js는 자체적으로 로깅 시스템을 제공하지 않고, 기본적으로 **`console.log`를 사용해 표준 출력(stdout)**에 로그를 남기는 방식이다. 이는 서버리스 환경에서도 잘 동작하며, AWS Lambda, Vercel과 같은 플랫폼에서도 로그를 수집하여 관리한다.

**장점**:

- **단순성**: 기본 Node.js 메서드를 활용하여 추가 설정 없이 로그를 남길 수 있음.
- **서버리스 호환성**: 별도의 로깅 설정 없이 플랫폼 로그 시스템으로 자동 전송.

**단점**:

- **구조화 부족**: 단순 문자열 로그는 분석이 어려움.
- **성능 부담**: 로그 출력은 I/O 작업이고, 트래픽이 많은 환경에서는 성능 병목이 될 수 있음.

### 1.2. 구조화된 로그 출력

구조화된 로그는 JSON 형식으로 데이터를 출력하여 분석 및 추적이 용이하며, 키바나와 로키 같은 외부 로그 분석 도구를 사용할 때 이점을 극대화할 수 있다.

아래와 같이 로그를 출력하면 로그 분석 도구를 사용할 때 필드별로 검색 혹은 필터링을 할 수 있다. 물론, 문자열 기반 로그를 작성하는 것보다 JSON 직렬화를 해야하므로 약간의 비용이 들 수 있다.

```javascript
export function logRequest(req) {
  const log = {
    level: 'info',
    timestamp: new Date().toISOString(),
    method: req.method,
    url: req.nextUrl.pathname,
    headers: Object.fromEntries(req.headers.entries()),
  };
  console.log(JSON.stringify(log));
}
```

출력 결과

```json
{
  "level": "info",
  "timestamp": "2024-11-19T12:00:00Z",
  "method": "GET",
  "url": "/api/example",
  "headers": {
    "user-agent": "Mozilla/5.0",
    "host": "localhost:3000"
  }
}
```

## 2. 중앙집중적 로깅 관리

`Next.js`의 미들웨어는 모든 요청을 처리하기 전에 실행되므로, 중앙집중적으로 로깅을 관리하는데 이상적이다. 모든 요청을 한 곳에서 관리하여 코드 중복이 줄어들고, 로깅 정책을 일관되게 적용할 수 있다.

### 2.1. 미들웨어에서 요청과 응답 로깅

```javascript
import { NextRequest, NextResponse } from 'next/server';

export function middleware(req) {
  console.log(`[${new Date().toISOString()}] Request: ${req.method} ${req.nextUrl.pathname}`);
  const response = NextResponse.next();
  console.log(`[${new Date().toISOString()}] Response: ${response.status}`);
  return response;
}
```

장점:

중앙 집중화: 모든 요청을 하나의 미들웨어에서 관리.
일관성: 로그 출력 방식과 포맷이 통일됨.
단점:

모든 요청을 처리하므로, 고트래픽 환경에서 성능 부담이 증가.

### 2.2. 불필요한 로그 필터링: 샘플링 로깅

고트래픽 환경에서는 모든 요청을 기록하는 대신, 샘플링 로깅을 통해 특정 비율로 로그를 기록함으로써 성능과 저장 비용을 최적화할 수 있습니다.

```javascript
import crypto from 'crypto';

function shouldLog(samplingRate) {
  const randomByte = crypto.randomBytes(1)[0];
  return randomByte / 255 < samplingRate;
}

export function middleware(req) {
  const samplingRate = 0.1; // 10%의 요청만 로깅
  if (shouldLog(samplingRate)) {
    console.log(`[${new Date().toISOString()}] ${req.method} ${req.nextUrl.pathname}`);
  }
  return NextResponse.next();
}
```

장점:

고트래픽 환경에서 로그 데이터의 양을 효과적으로 제한.
균일한 샘플링으로 유의미한 데이터 유지.
2.3. 중요 요청의 예외 처리
일부 요청(예: 인증, 결제 등)은 항상 로그에 기록되어야 하므로, 중요 요청은 샘플링과 관계없이 처리합니다.

```javascript
const criticalPaths = ['/auth/login', '/payment/process'];

export function middleware(req) {
  if (criticalPaths.includes(req.nextUrl.pathname)) {
    console.log(`[CRITICAL] ${req.method} ${req.nextUrl.pathname}`);
  } else {
    const samplingRate = 0.1;
    if (shouldLog(samplingRate)) {
      console.log(`[INFO] ${req.method} ${req.nextUrl.pathname}`);
    }
  }
  return NextResponse.next();
}
```

장점:

중요한 요청은 항상 기록.
샘플링과 결합하여 효율적 관리 가능. 3. 동기식 vs 비동기식 로깅

### 3.1. 동기식 로깅

동기식 로깅은 요청 처리 흐름과 같은 스레드에서 실행되며, 로깅 작업이 완료된 후 요청 처리가 진행됩니다.

장점:

신뢰성: 요청이 완료되기 전에 로그가 반드시 기록됨.
간단한 디버깅: 요청 흐름과 로그가 항상 동기화됨.
단점:

성능 저하: 로깅 작업이 요청 처리 속도를 저하시킬 수 있음.

```javascript
export function middleware(req) {
  console.log(`[CRITICAL] ${req.method} ${req.nextUrl.pathname}`);
  return NextResponse.next();
}
```

### 3.2. 비동기식 로깅

비동기식 로깅은 요청 처리와 로그 작성을 분리하여 성능 영향을 최소화합니다. setImmediate를 사용하면 요청-응답 흐름이 중단되지 않습니다.

장점:

성능 최적화: 요청 처리 속도가 빨라짐.
고트래픽 환경 적합: 비동기 실행으로 로깅 작업 분산.
단점:

로그 누락 가능성: 요청이 종료되기 전에 로그 작업이 완료되지 않을 위험.

```javascript
export function middleware(req) {
  setImmediate(() => {
    console.log(`[INFO] ${req.method} ${req.nextUrl.pathname}`);
  });
  return NextResponse.next();
}
```

### 3.3. 혼합 전략: 동기식 + 비동기식

중요한 로그는 동기식으로 처리하고, 일반 로그는 비동기식으로 처리하여 신뢰성과 성능을 동시에 확보합니다.

```javascript
export function middleware(req) {
  if (req.nextUrl.pathname === '/api/critical') {
    console.error(`[CRITICAL] ${req.method} ${req.nextUrl.pathname}`);
  } else {
    setImmediate(() => {
      console.log(`[INFO] ${req.method} ${req.nextUrl.pathname}`);
    });
  }
  return NextResponse.next();
}
```

## 4. 공식 문서 및 추가 참고 자료

Next.js와 Node.js의 로깅 관련 공식 문서를 참고하여 더 깊이 있는 설계를 할 수 있습니다.

Next.js Middleware
Node.js Timers (setImmediate)
Next.js Logging Options (next.config.js)

## 결론

Next.js에서 로깅은 단순한 출력 이상의 의미를 가지며, 성능 최적화와 데이터 신뢰성을 확보하기 위한 정교한 설계가 필요합니다.

최적 로깅 전략 요약
구조화된 로그: JSON 형식으로 출력하여 분석과 통합 용이.
중앙집중적 로깅: 미들웨어에서 로깅을 통합 관리.
샘플링 및 중요 요청 처리: 트래픽을 줄이고 중요한 데이터는 항상 기록.
동기식/비동기식 혼합: 성능과 신뢰성을 동시에 고려한 실행 방식.
이 전략은 Next.js 애플리케이션의 성능을 유지하면서도, 고트래픽 환경에서도 안정적인 로깅을 보장할 수 있습니다.
