---
id: 단위 테스트
title: '8장, 통합 테스트를 하는 이유'
description: '단위 테스트 책을 읽고 내용을 정리합니다.'
keywords: 'unit testing, book, study'
createdAt: 2022.04.20
---

단위 테스트에만 전적으로 으존하면 시스템이 전체적으로 잘 작동하는지 확신할 수 없다. 단위 테스트가 비지니스 로직을 확인하는 데 좋지만, 비지니스 로직을 외부와 돤절된 상태로 확인하는 것만으로는 충분하지 않다.
각 부분이 데이터베이스나 메시지 버스 등 외부 시스템과 어떻게 통합되는지 확인해야 한다.

## 8.1 통합 테스트는 무엇인가?

통합 테스트는 테스트 스위트에서 중요한 역할을 하며, 단위 테스트 개수와 통합 테스트 개수의 균형을 맞추는 것도 중요하다.

### 8.1.1 통합 테스트의 역할

**단위 테스트가 아닌 모든 테스트가 통합 테스트에 해당한다.**<br/>
실제 통합 테스트는 대부분 시스템이 프로세스 외부 의존성과 통합해 어떻게 작동하는지를 검증한다.<br/>
단위 테스트는 도메인 모델을 다루는 반면, 통합 테스트는 프로세스 외부 의존성과 도메인 모델을 연결하는 코드를 확인한다.

<img className='w-8/12 m-auto' src='/assets/images/unit-testing-28.jpg' />
<br />

간단한 코드는 노력을 들일만한 가치가 없고, 지나치게 복잡한 코드는 알고리즘과 컨트롤러로 리팩터링해야 한다.<br/>
**모든 테스트는 도메인 모델과 컨트롤러 사분면에만 초점을 맞춰야 한다.**

### 8.1.2 다시 보는 테스트 피라미드

단위 테스트와 통합 테스트의 비율은 프로젝트의 특성에 따라 다를 수 있지만, 일반적인 경험에 비춰본 규칙은 다음과 같다.<br/>
**단위 테스트로 가능한 한 많이 비지니스 시나리오의 예외 상황을 확인하고, 통합 테스트는 주요 흐름(happy path)과 단위 테스트가 다루지 못하는 기타 예외 상황(edge case)을 다룬다.**

> 주요 흐름은 시나리오의 성공적인 실행이다. 예외 상황은 비지니스 시나리오 수행 중 오류가 발생하는 경우다.

<img className='w-8/12 m-auto' src='/assets/images/unit-testing-29.jpg' />
<br />

테스트 피라미드는 프로젝트의 복잡도에 따라 모양이 많이 다를 수 있다. 단순 애플리케이션은 도메인 모델과 알고리즘 사분면에 거의 코드가 없다. 결국 테스트 구성이 피라미드 대신 직사각형이 되며, 단위 테스트와 통합 테스트의 수가 같다.
아주 단순한 경우라면, 어떠한 단위 테스트도 없을 것이다.<br/>
통합 테스트는 단순한 애플리케이션에서도 가치가 있다. 코드가 얼마나 간단한지보다 다른 서브 시스템과 통합해 어떻게 작동하는지 확인하는 것이 더 중요하다.

### 8.1.3 통합 테스트와 빠른 실패

통합 테스트에서 프로세스 외부 의존성과의 상호 작용을 모두 확인하려면 가장 긴 주요 흐름을 선택하라. 이렇게 모든 상호 작용을 거치는 흐름이 없으면, 외부 시스템과의 통신을 모두 확인하는 데 필요한 만큼 통합 테스트를 추가로 작성하라.<br/>
컨트롤러에서 `CanChangeEmail()`을 호출하는 것과 달리, `User`에 사전 조건이 있는지를 테스트해야 한다. 이는 단위 테스트로 하는 것이 더 낫고, 통합테스트는 필요하지 않다.<br/>
버그를 빨리 나타나게하는 것을 **빠른 실패 원칙(Fast Fail principle)**이라고 하며, 통합테스트에서 할 수 있는 대안이다.

> **빠른 실패 원칙**<br/><br/>
> 빠른 실패 원칙은 예기치 않은 오류가 발생하자마자 현재 연산을 중단하는 것을 의미한다.<br/>
> 이 원칙은 다음을 통해 애플리케이션의 안정성을 높인다.<br/><br/>
>
> - **피드백 루프 단축**: 버그를 빨리 발견할 수록 더 쉽게 해결할 수 있다. 운영 환경으로 넘어온 버그는 개발 중에 발견된 버그보다 수정 비용이 훨씬 더 크다.
> - **지속성 상태 보호**: 버그는 애플리케이션 상태를 손상시킨다. 손상된 상태가 데이터베이스로 침투하면, 고치기가 훨씬 어려워진다. 빨리 실패하면 손상이 확산되는 것을 막을 수 있다.<br/><br/>
>   보통 예외를 던져서 현재 연산을 중지한다. 예외는 그 의미가 빠른 실패 원칙에 완벽히 부합되기 때문이다. 예외는 프로그램 흐름을 중단하고 실행 스택에서 가장 높은 레벨로 올라간 후 로그를 남기고 작업을 종료하거나 재시작할 수 있다.

## 8.2 어떤 프로세스 외부 의존성을 직접 테스트해야 하는가?

## 8.3 통합 테스트: 예제

## 8.4 의존성 추상화를 위한 인터페이스 사용

단위 테스트 영역에서 가장 많이 오해하는 주제 중 하나는 인터페이스 사용이다. 인터페이스를 둔 이유를 개발자들이 자주 잘못 설명하고, 그 결과 남용하는 경향이 있다.

### 8.4.1 인터페이스와 느슨한 결합

많은 개발자가 데이터베이스나 메시지 버스와 같은 프로세스 외부 의존성을 위해 인터페이스를 도입한다. 심지어 인터페이스에 구현이 하나만 있는 경우에도 그렇다.<br/>
위와 같이 인터페이스를 사용하는 일반적인 이유는 인터페이스가

- 프로세스 외부 의존성을 추상화해 느슨한 결합을 달성하고,
- 공개 폐쇄 원칙(OCP)을 지키기 때문이다.

단일 구현을 위한 인터페이스는 추상화가 아니며, 해당 인터페이스를 구현하는 구체 클래스보다 결합도가 낮지 않다.<br/>
**진정한 추상화는 발견하는 것이지, 발명하는 것이 아니다.**<br/>
의미상 추상화가 이미 존재하지만 코드에서 아직 명확하게 정의되지 않았을 때 그 이후에 발견되는 것이다. 따라서, 인터페이스가 진정으로 추상화되려면 구현이 적어도 두 가지는 있어야 한다.<br/>

두 번째 OCP를 지킨다는 생각은 더 근본적인 원칙인 YAGNI를 위반하기 때문에 잘못된 생각이다. 여기에는 크게 두 가지 이유가 있다.

- **기회 비용**: 현재 비지니스 담당자들에게 필요하지 않은 기능에 시간을 보낸다면, 지금 당장 필요한 기능을 제치고 시간을 허비하는 것이다. 처음부터 실제 필요에 따라 기능을 구현하는 것이 유리하다.
- 프로젝트 코드가 적을수록 좋다. 요구 사항이 바로 있는 경우가 아닌데도 많일을 위해 코드를 작성하면 코드베이스의 소유 비용이 불필요하게 증가한다.

### 8.4.2 프로세스 외부 의존성에 인터페이스를 사용하는 이유는 무엇인가?

각 인터페이스에 구현이 하나만 있다고 가정할 때 프로세스 외부 의존성에 인터페이스를 사용하는 이유는 목을 사용하기 위함이다.<br/>
인터페이스가 없으면 테스트 대역을 만들 수 없으므로 테스트 대상 시스템과 프로세스 외부 의존성 간의 상호 작용을 확인할 수 없다.

### 8.4.3 프로세스 내부 의존성을 위한 인터페이스 사용

프로세스 외부 의존성과 마찬가지로 도메인 클래스에 대해 단일 구현으로 인터페이스를 도입하는 이유는 목으로 처리하기 위한 것뿐이다. 그러나 프로세스 외부 의존성과 달리 도메인 클래스 간의 상호 작용을 확인 해서는 안 된다.
그렇게하면 깨지기 쉬운 테스트로 이어지고, 결국 리팩터링 내성이 떨어지게 된다.

## 8.5 통합 테스트 모범 사례

### 8.5.1 도메인 모델 경계 명시하기

### 8.5.2 계층 수 줄이기

### 8.5.3 순환 의존성 제거하기

### 8.5.4 테스트에서 다중 실행 구절 사용
