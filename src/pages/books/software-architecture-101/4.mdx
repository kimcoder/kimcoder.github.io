---
id: 소프트웨어 아키텍처 101
title: '4장, 아키텍처 특성 정의'
description: '소프트웨어 아키텍처 101 책을 읽고 내용을 정리합니다.'
keywords: 'software architecture, fundamentals of software architecture, 소프트웨어 아키텍처 101, book, study'
createdAt: 2022.05.31
---

아키텍트는 개발팀과 함께 도메인 또는 비지니스 요구사항을 정의할 수 있지만, 주로 소프트웨어로 처리할 일 중 도메인 기능과 직접적인 관련이 없는 모든 것들, 즉 **아키텍처 특성(architectural characteristic)을 정의, 발견, 분석하는 일을 수행**한다.

아키텍처 특성은 다음 세 가지 기준을 충족한다.

- **비도메인 설계 고려 사항을 명시한다.**
- **설계의 구조적 측면에 영향을 미친다.**
- **애플리케이션 성공에 중요하다.**

### 비도메인 설계 고려 사항을 명시한다

애플리케이션 설계 시 애플리케이션으로 처리할 일은 구체적인 요구사항으로 정리한다. 아키텍처 특성은 이 요구사항을 구현하는 방법, 어떤 선택을 하게 된 이유와 관련된 운영/설계 기준을 명시한다.
예를 들어, 애플리케이션 성능은 중요한 아키텍처 특성이지만 요구사항 정의서에는 적혀있지 않은 경우가 많다. 또 다른 예로, 기술 부채 방지는 아키텍트와 개발자의 당연한 설계 고려 사항이다.

### 설계의 구조적 측면에 영향을 미친다

아키텍트가 아키텍처 특성을 기술하는 주된 이유는, 이 아키텍처 특성은 어떤 특별한 구조적 요소를 고려해야 하는가? 하는 설계 고려 사항 때문이다.
예를 들어, 보안은 사실상 모든 프로젝트의 주요 관심사이고 기본 보안 지침을 만들어 준수해야 하지만, 아키텍트가 뭔가 특별한 것을 설계해야 한다면 보안은 아키텍처 특성 수준으로 격상된다.

예를 들어. 결제 시스템에 관한 두 가지 사례를 살펴보자.

- 서드파티 결제 프로세서<br/>
  결제 처리를 한곳에서 처리한다면 특별히 구조에 신경 쓸 일이 없다. 암호화, 해시 등의 보안 장치를 설계에 반영할 필요는 있지만 어떤 구조가 필요한 것은 아니다.
- 애플리케이션 내부 결제 처리<br/>
  애플리케이션이 직접 결제 처리를 한다면 아키텍트는 중요한 보안 문제를 구조적으로 분리하기 위해 특정한 모듈이나 컴포넌트, 서비스를 설계해야 한다. 이 경우 아키텍처 특성은 아키텍처와 설계 모두에 영향을 미친다.

### 애플리케이션 성공에 (절대적으로) 중요하다

애플리케이션이 무수히 많은 아키텍처 특성을 전부 다 지원할 수도 있겠지만 사실 그러면 안 된다. 그만큼 설계 복잡도는 가중되고, 가급적 아키텍처 특성을 적게 선정하는 것도 아키텍트의 중요한 책무이다.

**우리는 아키텍처 특성을 명시적 특성과 암묵적 특성으로 분류한다.**<br/>
암묵적 아키텍처 특성은 요구사항 정의서에는 거의 안 나오지만 프로젝트 성공을 위해 꼭 필요한 특성들이다. 가령, 가용성, 신뢰성, 보안은 거의 모든 애플리케이션의 근간이지만 설계 문서에는 좀처럼 등장하지 않는다.

명시적 아키텍처 특성은 요구사항 정의서나 다른 지침서에 기재된다.

## 4.1 아키텍처 특성 (일부) 목록

아키텍처 특성은 모듈성 같은 저수준 코드의 특성부터 확장성, 탄력성 같은 복잡한 운영 문제까지 소프트웨어 시스템의 넓은 범위에 고루 존재한다.<br/>
아직도 보편적인 표준은 없으며 조직마다 자체적으로 해석 후 용어를 정의한다.<br/>
빠르게 변화하는 소프트웨어 생태계 특성상 새로운 개념, 용어, 측정, 검증이 계속 출현하기 때문에 계속 새로운 방식으로 아키텍처 특성을 정의하게 된다.

### 4.1.1 운영 아키텍처 특성

| 용어                            | 정의                                                                                                                                                          |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 가용성, availability            | 시스템이 얼마나 오랫동안 사용 가능해야 하나? (24/7이면 장애 발생 시 시스템을 신속하게 재가동시키는 절차가 준비되어야 함)                                      |
| 연속성, continuity              | 재해 복구 능력                                                                                                                                                |
| 성능, performance               | 스트레스 테스트, 피크 분석, 기능의 사용 빈도 분석, 필요 용량, 응답 시간, 이 정도 성능이면 됐다 싶으려면 직접 돌려봐야 하는데 그 기간만 대략 수 개월 소요된다. |
| 복구성, recoverability          | 비즈니스 연속성 요구사항(예를 들어, 장애 발생 시 얼마나 신속하게 시스템을 재가동시켜야 하나?). 백업 전략과 하드웨어 다중화 요건에 영향을 미친다.              |
| 신뢰성/안전, reliability/safety | 시스템에 페일 세이프(fail-safe)가 필요한가? 즉, 페일 세이프가 시스템 가동에 필수인가? 시스템 실패시 거액의 손실이 발생하는가?                                 |
| 견고성, robustness              | 프로그램 실행 중 인터넷 접속 끊김. 정전, 하드웨어 실패 등 에러 및 경계 조건을 감당하는 능력                                                                   |
| 확장성, scalability             | 유저 수, 요청 수가 늘어나도 시스템이 그에 맞는 성능을 발휘하는 능력                                                                                           |

운영 아키텍처 특성은 운영 및 데브옵스와 많은 부분에서 중첩되며, 많은 소프트웨어 프로젝트에서 이런 관심사는 교차점을 형성한다.

### 4.1.2 구조 아키텍처 특성

아키텍트는 코드 구조에도 심혈을 기울여야 하며, 일반적으로 우수한 모듈성, 컴포넌트 간 커플링 제어, 가독성 높은 코드, 그 밖의 내부 품질 평가 등 코드 품질 문제를 전담(또는 공동으로 담당)한다.

| 용어                         | 정의                                                                                                                                           |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| 설정성, configurability      | 최종 유저가 (쓰기 편한 인터페이스를 통해) 소프트웨어 설정을 쉽게 바꿀 수 있는가?                                                               |
| 신장성, extensibility        | 새로운 기능을 삽입하는 일의 중요성                                                                                                             |
| 설치성, extensibility        | 필요한 모든 플랫폼에 시스템을 얼마나 손쉽게 설치할 수 있나?                                                                                    |
| 활용성/재사용, extensibility | 공통 컴포넌트를 여러 제품에서 활용할 수 있나?                                                                                                  |
| 지역성, locality             | 데이터를 입력/조회하는 화면에서 다국어가 지원되는가? 리포트 장표에서 멀티바이트 문자 및 측정, 화폐 단위 등의 요구사항.                         |
| 유지보수성, maintainability  | 시스템을 얼마나 쉽게 변경/개선할 수 있나?                                                                                                      |
| 이식성, portability          | 하나 이상의 플랫폼에서 시스템을 실행할 수 있나? (가령, 동일한 프런트엔드를 SAP DB과 오라클 데이터베이스에서 모두 실행할 수 있는가?)            |
| 지원성, supportability       | 애플리케이션은 어느 정도의 기술 지원을 필요로 하나? 시스템에서 발생한 에러를 디버깅하려면 로깅 및 기타 기능이 어느 수준으로 뒷받침되어야 하나? |
| 업그레이드성, extensibility  | 이 애플리케이션/솔루션의 구 버전을 새 버전으로 쉽고 빠르게 업그레이드할 수 있는가?                                                             |

### 4.1.3 아키텍처 공통 특성

쉽게 분류할 수 있는 범주에 속하는 아키텍처 특성들도 있는 반면, 중요한 설계 제약조건과 고려 사항은 대부분 따로 분류하기가 어려운 경우가 많다.

| 용어                                  | 정의                                                                                                                                                                                                                          |
| ------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 접근성, accessibility                 | 색맹, 청각 장애인 등 모든 유저가 접근하는 데 불편함이 없나?                                                                                                                                                                   |
| 보관성, archivability                 | 데이터를 따로 아카이빙해야 하나, 아니면 일정 시간 경과 후 삭제해야 하나? (예를 들어, 고객 계정은 3개월 후 삭제하거나 미사용 계정으로 표시하되 차후 해당 고객이 다시 접속할지 모르기 때문에 보조 데이터베이스에 아카이빙한다.) |
| 인증, authentication                  | 유저가 본인이 맞다는 것을 증명하기 위해 필요한 보안 요구사항                                                                                                                                                                  |
| 인가, authorization                   | (유스 케이스, 서브시스템, 웹페이지, 비지니스 규칙, 필드 레벨 등) 유저가 애플리케이션에서 정해진 기능만 사용할 수 있도록 강제하는 보안 요구사항                                                                                |
| 합법성, legal                         | 시스템 운영상 법적 제약조건이 있는가? 회사는 어떤 권리를 유보해야 하나? 애플리케이션을 개발/배포하는 방법에도 따로 법정 규정이 있나?                                                                                          |
| 프라이버시, privacy                   | 회사 내부 임직원의 트랜잭션을 외부에 드러내지 않는 기능                                                                                                                                                                       |
| 보안, security                        | 데이터를 암호환 후 데이터베이스에 보관해야 하나? 내부 시스템 간 네트워크 통신도 암호화해야 하나? 원격 유저 엑세스는 어떤 종류의 인증이 필요한가?                                                                              |
| 사용성/성취성, usability/achievaility | 유저가 애플리케이션/솔루션을 이용하여 원하는 목적을 달성하기 위해 필요한 교육/훈련 수준. 사용성 요구사항 역시 다른 아키텍처 이슈 못지않게 진지하게 다루어야 한다.                                                             |

아키텍처 특성은 어떻게 나열해도 불완전한 목록이 될 수 밖에 없고, 소프트웨어마다 고유한 팩터를 바탕으로 중요한 아키텍처 특성이 도출될 수도 있다.

또한, 설명된 용어들은 대부분 의미가 미묘하거나, 객관적으로 정의하기 어렵거나, 다소 부정확하고 모호한 부분도 있다.

예를 들어, 학습성은 유저가 소프트웨어 얼마나 쉽게 배울 수 있는가를 나타내는 아키텍처 특성이지만, 머신 러닝 알고리즘을 통해 자신이 처한 환경의 정보를 자동으로 습득하는 수준을 가리키는 경우도 있다.

정의가 중복되는 것들도 많다. 가용성과 신뢰성은 사실 거의 모든 케이스에 중복된다.

## 4.2 트레이드오프 및 나쁜 것 중에서 제일 나은 아키텍처

아키텍처 특성들은 여러 가지 이유로 일부만 애플리케이션에서 지원 가능하다.<br/>
첫째, 지원되는 특성마다 설계 노력이 필요하고 구조적으로도 지원돼야 한다.<br/>
둘째, 각 아키텍처 특성이 다른 특성에 영향을 미치는 경우가 많다는 사실이 더 큰 문제이다. 예를 들어, 보안을 강화하려고 하면 십중팔구 성능에 부정적인 영향을 끼친다.

시스템을 설계하며 모든 아키텍처 특성을 빠짐없이 최상으로 반영하기란 불가능에 가깝다. 아키텍트가 내린 결정은 상충되는 여러 문제들이 뒤얽힌 트레이드오프로 귀결되는 경우가 많다.

> **최고의 아키텍처를 고집하지 말고 나쁜 것 중에서 제일 나은 아키텍처를 선택하세요.**

아키텍트는 가능한 한 아키텍처 설계를 꾸준히 조금씩 반복해보는 게 좋다. 아키텍처를 쉽게 변경할 수 있다면 첫술에 배불러야 한다는 강박관념도 사라지겠죠.
반복의 가치는 애자일 소프트웨어 개발에서도 가장 중요한 교훈 중 하나로, 아키텍처뿐만 아니라 모든 레벨의 소프트웨어 개발에도 적용된다.
