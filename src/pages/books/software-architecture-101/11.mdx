---
id: 소프트웨어 아키텍처 101
title: '11장, 파이프라인 아키텍처 스타일'
description: '소프트웨어 아키텍처 101 책을 읽고 내용을 정리합니다.'
keywords: 'software architecture, fundamentals of software architecture, 소프트웨어 아키텍처 101, book, study'
createdAt: 2022.07.11
---

**파이프라인 아키텍처(pipeline architecture, 파이프와 필터 아키텍처라고도 함)는 소프트웨어 아키텍처에서 끊임없이 등장하는 기본적인 아키텍처 스타일입니다.**
**개발자와 아키텍트가 기능을 개별 파트로 분리하기로 결정하는 순간부터 이 패턴이 수반된다.**

함수형 언어 개발자는 언어 구조와 이 아키텍처 요소가 유사하다고 생각할 것이다. 사실, 맵리듀스(MapReduce) 프로그래밍 모델을 응용한 많은 도구가 이 기본 토폴로지를 따릅니다.
이처럼 파이프라인 아키텍처 스타일은 저수준에서 구현할 수도 있고 고수준의 비지니스 애플리케이션에도 적용할 수 있다.

## 11.1 토폴로지

파이프라인 아키텍처는 다수의 파이프와 필터로 구성된다.

<img className='w-8/12 m-auto' src='/assets/images/software-architecture-101-26.jpg' />
<br />

파이프와 필터는 특정한 방식으로 조정되며, 보통 필터 간 단방향 통신은 점대점 방식으로 구성한다.

## 11.1.1 파이프

파이프는 한 소스에서 입력을 받아 다른 소스로 출력을 내는, 필터 간 통신 채널이다. 파이프는 성능상 이유로 보통 단방향, 점대점 방식으로 구성한다.
파이프를 오가는 페이로드의 데이터는 어떤 포맷이라도 가능하지만, 아키텍트는 고성능에 유리한 적은 양의 데이터를 선호한다.

## 11.1.2 필터

필터(filter)는 자기 완비형(self-contained)이고, 다른 필터와 독립적이며, 일반적으로 무상태성(stateless)이다. 필터는 한 가지 태스크만 수행하므로 복합 태스크는 여러 필터를 이어 붙여 처리하면 된다.

### 프로듀서, producer

프로세스의 시작점이다. 아웃바운드(outbound)만 있어서(즉, 들어오는 트래픽은 없고 나가는 트래픽만 있기 때문에) 소스(source)라고도 한다.

### 변환기, transformer

입력을 받아 필요시 일부 또는 전체 데이터를 변환한 후, 그 결과를 아웃바운드 파이프로 전달한다. 함수형 프로그래밍의 열혈팬들은 이 기능을 맵(map)이라고 부른다.

### 테스트, tester

입력을 받아 하나 이상의 기준(criteria)에 대해 테스트를 하고 그 결과에 따라 필요시 결과를 생산합니다. 함수형 프로그래머는 이 기능을 리듀스(reduce)라고 부른다.

### 컨슈머, consumer

파이프라인 흐름의 종착엽니다. 컨슈머는 파이프라인 프로세스의 최종 결과를 데이터베이스에 저장하거나 유저 인터페이스 화면에 표시한다.

각 파이프와 필터는 단방향이고 워낙 단순해서 얼마든지 조합할 수 있다.

## 11.2 예제

파이프라인 아키텍처 패턴은 다양한 애플리케이션, 특히 간단한 단방향 처리 태스크에서 흔히 찾아볼 수 있다. 예를 들어, 전자 데이터 교환(electronic data interchange, EDI) 도구는 대부분 이 패턴에 따라 파이프와 필터로 한 종류의 문서를 다른 종류의 문서로 변환한다.

<img className='w-8/12 m-auto' src='/assets/images/software-architecture-101-27.jpg' />
<br />

위의 그림을 보면서 파이프라인 아키텍처의 쓰임새를 알아보자.

서로 다른 종류의 데이터를 카프카에 스트리밍 처리하는 파이프라인 아키텍처 스타일의 용례를 눈 여겨 보자.
서비스 정보 캡처(프로듀서) 필터는 카프카 토픽을 구독하여 서비스 정보를 받아 이 데이터를 지속 시간 필터라는 테스터 필터에 보내고 카프카에서 받아온 데이터가 서비스 요청 지속 시간과 연관되어 있는지 판단한다.
필터마다 관심사도 분리되어 있다. 서비스 정보 필터는 카프카 토픽에 연결하는 일만 신경을 쓰고, 지속 시간 필터는 데이터 검증 후 필요시 다음 파이프에 보내는 작업만 한다.
만약 데이터가 서비스 요청 지속 시간과 관련이 있으면 지속 시간 필터는 이 데이터를 지속 시간 계산기 필터로 전달하고, 관련이 없으면 가동 시간 필터로 보낸다.
가동 시간 메트릭과 관련이 없으면 해당 데이터는 특정한 처리 흐름에 아무 쓸모가 없으므로 파이프라인은 즉시 종료된다.
반대로 가동 시간 메트릭과 관련이 있으면, 가동 시간 계산기(변환기) 필터로 보내 해당 서비스의 가동 시간 메트릭을 계산한다.

이 예제는 파이프라인 아키텍처의 확장성을 잘 나타낸다.
데이터베이스 접속 대기 시간처럼 새로 수집된 메트릭을 데이터베이스에 전달해야 할 경우, 간단히 가동 시간 필터 다음에 테스트 필터를 하나 더 추가하면 된다.

## 11.3 아키텍처 특성 등급

| 아키텍처 특성 | 별점       |
| ------------- | ---------- |
| 분할 유형     | 기술       |
| 퀀텀 수       | 1          |
| 배포성        | ⭐         |
| 탄력성        | ⭐         |
| 진화성        | ⭐         |
| 내고장성      | ⭐         |
| 모듈성        | ⭐         |
| 전체 비용     | ⭐⭐⭐⭐⭐ |
| 성능          | ⭐⭐       |
| 신뢰성        | ⭐⭐⭐     |
| 확장성        | ⭐         |
| 단순성        | ⭐⭐⭐⭐⭐ |
| 시험성        | ⭐⭐       |

**파이프라인 아키텍처 스타일은 애플리케이션 로직을 필터 타입(프로듀서, 테스터, 변환기, 컨슈머)에 따라 나누는, 기술 분할 아키텍처이다.**
