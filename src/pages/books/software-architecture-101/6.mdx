---
id: 소프트웨어 아키텍처 101
title: '6장, 아키텍처 특성의 측정 및 거버넌스'
description: '소프트웨어 아키텍처 101 책을 읽고 내용을 정리합니다.'
keywords: 'software architecture, fundamentals of software architecture, 소프트웨어 아키텍처 101, book, study'
createdAt: 2022.06.21
---

## 6.1 아키텍처 특성 측정

아키텍처 특성을 정의할 때에는 흔히 다음과 같은 문제들이 발생한다.

#### 물리학이 아니다

아키텍처 특성은 대부분 의미가 모호하다. 동일한 용어도 업계에서 바라보는 시각이 제각각이고 법적인 상황에 따라 좌지우지되거나 우발적으로 의미가 정해지는 경우도 있다.

#### 정의가 너무 다양하다

성능 같은 중요한 특성에 대한 정의가 같은 조직에서도 부서마다 일치하지 않아 개발자, 아키텍트, 운영자 모두 정의를 통일하기 전까지는 원활하게 소통하기가 어렵다.

#### 너무 복합적이다

바람직한 아키텍처 특성은 대부분 더 작은 여러 특성들로 구성된다. 예를 들어, 개발자는 민첩성을 모듈성, 배포성, 시험성 등의 특성으로 세분화할 수 있다.

이 세 가지 문제는 아키텍처 특성을 객관적으로 정의하면 모두 해결된다. 아키텍처 특성을 명확하게 정의하고 조직 전체가 이에 동의하면 팀은 공통의 아키텍처 언어를 확립할 수 있다.
또 복합적인 특성은 더 잘게 나누어 분석해보면 객관적으로 정의할 수 있는, 측정 가능한 특성을 밝혀낼 수 있다.

### 6.1.1 운영적 측정

아키텍처 특성은 성능, 확장성처럼 비교적 정확하게 측정할 수 있는 것도 많지만, 팀 목표에 따라 그에 따른 해석은 미묘하게 갈릴 때가 많습니다.
예를 들어, 특정 요청에 대한 평균 응답 시간을 측정할 경우, 어떤 경계 조건 때문에 1%의 요청이 다른 요청보다 처리 시간이 10배나 오래 걸리면 어떻게 해야 할까요? 사내 네트워크 리소스가 충분하다면 특이점은 나타나지 않을 수 있으니 최대 응답 시간도 함께 측정해야 특이점까지 잡아낼 수 있을 것이다.

**수준 높은 팀은 달성하기 어려운 성능 수치를 정하는 대신, 통계 분석 결과로 얻은 나름대로의 정의에 기반한다.** 예를 들어, 확장성을 모니터링하는 비디오 스트리밍 서비스 업체가 있다고 하자.
엔지니어는 시간에 따라 어떤 추이를 보이는지 측정하고 통계 모델을 수립한다. 그리고 실시간 수집한 메트릭이 예측 모델에서 벗어난 경우에 알림 메시지를 보낸다.
만약, 이 과정이 수포로 돌아간다면 원인은 모델 자체가 부정확했거나, 뭔가가 잘못되었거나 두 가지 중 하나일 것이다.

도구가 발전하고 이해도가 높아지면서 팀이 특정할 수 있는 아키텍처 특성은 빠르게 진화하고 있다.
예를 들어, 요즘은 최초 콘텐츠 렌더링(First Contentful Paint)와 최초 CPU 유휴(First CPU idle) 같은 메트릭에 성능 예산을 집중해서 모바일 기기로 접속한 유저의 성능 문제를 비중 있게 다루는 경우도 많다.
기기, 목표, 능력, 기타 다른 많은 것들이 변할수록 팀은 새로운 것을 발견하고 그것을 측정할 새로운 방법을 찾게 될 것이다.

### 6.1.2 구조적 측정

성능처럼 목표치가 확실하지 않은 메트릭도 있다. 잘 정의된 모듈성처럼 내부 구조에 관한 특성도 그렇다. 아직 내부 코드 품질에 대한 종합적인 메트릭은 없지만, 아키텍트는 다른 메트릭과 공통 도구를 이용해서 코드 구조에 관한 중요한 부분들을 들여다볼 수 있다.

**코드의 복잡도는 순환 복잡도(cyclomatic complexity, CC)라는 메트릭을 통해 명쾌하게 측정할 수 있다.**

> **순환 복잡도**
>
> <br />
> 순환 복잡도(CC)는 1976년 토마스 맥케이브가 개발한 코드 레벨의 메트릭이다.
>
> 함수/메서드, 클래스, 또는 애플리케이션 레벨에서 코드 복잡도를 객관적으로 나타내는 지표입니다.
>
> CC는 코드에 그래프 이론을 적용하여 계산한다.
>
> <br />
> 실행 경로(excutaion path)를 유발하는 결정점(decision point)을 이용한다. 예를 들어, 어떤 함수에 (if문 같은) 결정문이 하나도
> 없다면 CC = 1이고, 조건 분기가 하나 있으면 실행 경로는 두 갈래로 갈라지므로 CC = 2이다.
>
> <br />
> <br />
> 함수나 메서드에서 CC를 구하는 공식은 CC = E - N + 2이다. 여기서 N은 노드(node, 코드 라인), E는 간선(edge, 가능한
> 결정)이다.
> <br />
> 공식 끝부분에 있는 2는 단일 함수/메서드를 단순화한 값이다.
> <br />
> 다른 메서드도 호출하는 경우까지 고려한 일반 공식은 CC = E - N + 2P이다.(P는 연결된 컴포넌트 수)

```c
// 순환 복잡도를 계산하는 코드

public void decision(int c1, int c2) {
  if (c1 < 100)
    return 0;
  else if (c1 + c2 > 500)
    return -1;
  else
    return 1;
}
```

위 코드의 순환 복잡도를 구하면 `5 - 4 + 2 = 3`이다. (아래그림)

<img className='w-8/12 m-auto' src='/assets/images/software-architecture-101-8.jpg' />
<br />

### 6.1.3 프로세스 측정

소프트웨어 개발 프로세스와 교차하는 아키텍처 특성도 있다. 예를 들어, 민첩성은 바람직한 특성으로 보일 때가 많은데, 이는 시험성, 배포성 등의 특성으로 나눌 수 있는 복합적인 아키텍처 특성이다.

시험성은 거의 모든 플랫폼에서 테스트의 완전성을 평가하는 코드 커버리지 도구로 측정할 수 있다. 물론, 소프트웨어 체크가 다 그렇듯이 시험성도 사고(thinking)와 의도(intent)를 대체할 수는 없다.
그러나 어쨌든 시험성은 분명히 객관적으로 측정할 수 있는 특성이다. 마찬가지로, 배포성 역시 실패 대비 배포 성공률, 배포 소요 시간, 배포 시 발생한 이슈/버그 등 다양한 메트릭으로 측정된다.

양과 질 모든 면에서 조직에 유용한 데이터를 포착할 수 있는 측정 세트는 각 팀별로 알아서 준비해야 한다. 또 이렇게 측정한 메트릭들은 실제로 대부분 팀의 우선순위, 목표가 된다.

## 62.1 거버넌스와 피트니스 함수

### 6.2.1 아키텍처 특성 관리

거버넌스(governance)는 kubernan(이끌다, streer)라는 그리스어에서 유래된 말이다. 거버넌스는 아키텍트가 담당하는 중요한 업무이다. 아키텍처 거버넌스는 이름에서도 느껴지지만 아키텍트가 영향력을 행사하려는 모든 소프트웨어 개발 프로세스를 포괄한다.

### 6.2.2 피트니스 함수
